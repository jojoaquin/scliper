var J=Object.defineProperty;var o=(e,s)=>J(e,"name",{value:s,configurable:!0});import{r as Q}from"./get-pipe-path-BHW2eJdv.mjs";import g from"node:module";import d from"node:path";import{fileURLToPath as T}from"node:url";import{parseTsconfig as k,getTsconfig as z,createFilesMatcher as B,createPathsMatcher as G}from"get-tsconfig";import H from"node:fs";import{b as X,i as K,a as V}from"./index-DeKCL_WS.mjs";import{p as M}from"./client-BQVF1NaW.mjs";const Y=[".js",".json",".ts",".tsx",".jsx"],P=Object.create(null);P[".js"]=[".ts",".tsx",".js",".jsx"],P[".jsx"]=[".tsx",".ts",".jsx",".js"],P[".cjs"]=[".cts"],P[".mjs"]=[".mts"];const R=o((e,s)=>{const n=e.split("?");let[r]=n;const t=d.extname(r);let a=P[t];if(a)r=r.slice(0,-t.length);else{if(!s)return;a=Y}return a.map(c=>r+c+(n[1]?`?${n[1]}`:""))},"mapTsExtensions"),Z=o(e=>{const s=e.indexOf(":");if(s!==-1)return e.slice(0,s)},"getScheme"),U=o(e=>e[0]==="."&&(e[1]==="/"||e[1]==="."||e[2]==="/"),"isRelativePath"),q=o(e=>U(e)||d.isAbsolute(e),"isUnixPath"),ee=o(e=>{if(q(e))return!0;const s=Z(e);return s&&s!=="node"},"requestAcceptsQuery"),F="file://",L=/\.([cm]?ts|[tj]sx)($|\?)/,se=/\.json($|\?)/,te=/\/(?:$|\?)/,$=/^(?:@[^/]+\/)?[^/\\]+$/;let y,b,E=!1;const W=o(e=>{let s=null;if(e){const n=d.resolve(e);s={path:n,config:k(n)}}else{try{s=z()}catch{}if(!s)return}y=B(s),b=G(s),E=s?.config.compilerOptions?.allowJs??!1},"loadTsconfig"),_=o(e=>Array.from(e).length>0?`?${e.toString()}`:"","urlSearchParamsStringify"),S=[".ts",".tsx",".jsx"],A=o((e,...s)=>{for(const n of S){const r=s.slice();r[0]+=n;try{return e(...r)}catch{}}},"tryExtensions"),ne=o(e=>(s,...n)=>{try{return e(s,...n)}catch(r){const t=r;if(t.code==="MODULE_NOT_FOUND"&&!$.test(s)){const a=A(e,s,...n)||A(e,`${s}${d.sep}index`,...n);if(a)return a}throw t}},"createImplicitResolver"),re=`${d.sep}node_modules${d.sep}`,D=o(e=>{if(!e.startsWith("data:text/javascript,"))return;const s=e.indexOf("?");if(s===-1)return;const r=new URLSearchParams(e.slice(s+1)).get("filePath");if(r)return r},"getOriginalFilePath"),N=o(e=>{const s=D(e);return s&&(g._cache[s]=g._cache[e],delete g._cache[e],e=s),e},"interopCjsExports"),j=o((e,s,n)=>{if(!(n?.filename&&L.test(n.filename))&&!E)return;const r=R(s);if(r)for(const t of r)try{return e(t)}catch(a){const{code:c}=a;if(c!=="MODULE_NOT_FOUND"&&c!=="ERR_PACKAGE_PATH_NOT_EXPORTED")throw a}},"resolveTsFilename"),ae=o((e,s,n)=>{if(e.startsWith(F)&&(e=T(e)),b&&!U(e)&&!s?.filename?.includes(re)){const t=b(e);for(const a of t){const c=j(n,a,s);if(c)return c;try{return n(a)}catch{}}}const r=j(n,e,s);if(r)return r;try{return n(e)}catch(t){const a=t;if(a.code==="MODULE_NOT_FOUND"&&typeof a.path=="string"&&a.path.endsWith(`${d.sep}package.json`)){const c=a.message.match(/^Cannot find module '([^']+)'$/);if(c){const p=c[1],f=j(n,p,s);if(f)return f}const i=a.message.match(/^Cannot find module '([^']+)'. Please verify that the package.json has a valid "main" entry$/);if(i){const p=i[1],f=j(n,p,s);if(f)return f}}throw a}},"resolveRequest"),oe=o((e,s,n)=>(r,t,a,c)=>{if(e.enabled===!1)return s(r,t,a,c);const i=o(u=>s(u,t,a,c),"resolve");if(r=N(r),t?.filename){const u=D(t.filename);u&&(t.filename=u.split("?")[0])}const p=r.split("?"),f=new URLSearchParams(p[1]);if(t?.filename){const m=new URLSearchParams(t.filename.split("?")[1]).get("namespace");m&&f.append("namespace",m)}if((f.get("namespace")??void 0)!==n)return i(r);n&&(s=ne(s));let h=ae(p[0],t,i);return d.isAbsolute(h)&&!h.endsWith(".json")&&!h.endsWith(".node")&&(h+=_(f)),h},"createResolveFilename"),ce=`
//# sourceMappingURL=data:application/json;base64,`,C=o(()=>process.sourceMapsEnabled??!0,"shouldApplySourceMap"),w=o(({code:e,map:s})=>e+ce+Buffer.from(JSON.stringify(s),"utf8").toString("base64"),"inlineSourceMap"),ie=[".cts",".mts",".ts",".tsx",".jsx"],le=[".js",".cjs",".mjs"],O=o((e,s,n,r)=>{const t=Object.getOwnPropertyDescriptor(e,s);t?.set?e[s]=n:(!t||t.configurable)&&Object.defineProperty(e,s,{value:n,enumerable:t?.enumerable||r?.enumerable,writable:r?.writable??(t?t.writable:!0),configurable:r?.configurable??(t?t.configurable:!0)})},"safeSet"),fe=o((e,s,n)=>{const r=s[".js"],t=o((a,c)=>{if(e.enabled===!1)return r(a,c);const[i,p]=c.split("?");if((new URLSearchParams(p).get("namespace")??void 0)!==n)return r(a,i);M?.send&&M.send({type:"dependency",path:i});const h=ie.some(l=>i.endsWith(l)),u=le.some(l=>i.endsWith(l));if(!h&&!u)return r(a,i);let m=H.readFileSync(i,"utf8");if(i.endsWith(".cjs")){const l=X(c,m);l&&(m=C()?w(l):l.code)}else if(h||K(m)){const l=V(m,c,{tsconfigRaw:y?.(i)});m=C()?w(l):l.code}a._compile(m,i)},"transformer");O(s,".js",t);for(const a of S)O(s,a,t,{enumerable:!n,writable:!0,configurable:!0});return O(s,".mjs",t,{writable:!0,configurable:!0}),()=>{s[".js"]===t&&(s[".js"]=r);for(const a of[...S,".mjs"])s[a]===t&&delete s[a]}},"createExtensions"),I=o((e,s)=>{if(!s)throw new Error("The current file path (__filename or import.meta.url) must be provided in the second argument of tsx.require()");return e.startsWith(".")?((typeof s=="string"&&s.startsWith("file://")||s instanceof URL)&&(s=T(s)),d.resolve(d.dirname(s),e)):e},"resolveContext"),me=o(e=>{const{sourceMapsEnabled:s}=process,n={enabled:!0};W(process.env.TSX_TSCONFIG_PATH),process.setSourceMapsEnabled(!0);const r=g._resolveFilename,t=oe(n,r,e?.namespace);g._resolveFilename=t;const a=fe(n,g._extensions,e?.namespace),c=o(()=>{s===!1&&process.setSourceMapsEnabled(!1),n.enabled=!1,g._resolveFilename===t&&(g._resolveFilename=r),a()},"unregister");if(e?.namespace){const i=o((f,h)=>{const u=I(f,h),[m,l]=u.split("?"),x=new URLSearchParams(l);return e.namespace&&!m.startsWith("node:")&&x.set("namespace",e.namespace),Q(m+_(x))},"scopedRequire");c.require=i;const p=o((f,h,u)=>{const m=I(f,h),[l,x]=m.split("?"),v=new URLSearchParams(x);return e.namespace&&!l.startsWith("node:")&&v.set("namespace",e.namespace),t(l+_(v),module,!1,u)},"scopedResolve");c.resolve=p,c.unregister=c}return c},"register");export{se as a,w as b,F as c,ee as d,te as e,y as f,b as g,E as h,N as i,$ as j,W as l,R as m,me as r,L as t};
